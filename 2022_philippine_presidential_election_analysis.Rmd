---
title: "2022 Presidential Elections Data"
output: html_notebook
---

This is a personal project that aims to analyze the Philippine 2022 Presidential Election using the programming language, R. This project is based on Project Raven's Tableau [project](https://www.facebook.com/61562294530876/posts/pfbid02bwLWd45JfRSiCbmaFYBJRfM4WbYD6diK8rBAHRzoDjDwoZF8DWW8HZJ6gKJRhp9tl/). 

My personal aim in achieving this project is to avoid using any AI for assistance to fully immerse myself with the fundamentals and avoid reliance.

This project will use the dataset from Figshare: click [here](https://figshare.com/articles/dataset/2022_Presidential_Elections_Data/19755469?file=35101492) to download the dataset.

## Setting Up the Environment

```{r Setting Up the Environment}
packages <- c("tidyverse", "readr", "dplyr", "janitor", "ggplot2", 
              "plotly", "scales", "sf", "tmap")

# Regular CRAN packages
cran_packages <- setdiff(packages, "tmap")

# Install only missing CRAN packages
install_if_missing <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
}

lapply(cran_packages, install_if_missing)

# Special install for 'tmap' from r-universe
if (!requireNamespace("tmap", quietly = TRUE)) {
  install.packages("tmap", repos = c("https://r-tmap.r-universe.dev",
                                     "https://cloud.r-project.org"))
}

# Load all libraries
lapply(packages, library, character.only = TRUE)
```

## Reading the Dataset

Importing the dataset to the dataframe. In this case, the dataset is named as presidential_election.csv, feel free to change it to your preference!

```{r Data Frame Iniation}
pres_df <- data.frame(read_csv("presidential_election.csv"))

```


## Studying the Dataset

Here, I studied the structure of the dataset and the connection of each column to one another.

```{r Dataset Structure}
# head(pres_df)
# str(pres_df)
colnames(pres_df)
```

## Analysis 

This section will now take a closer look on the results of the 2022 election. Here, I added a dataframe that shows the candidates' names along with their campaign colors just for reference.

```{r Candidate Names and Campaign Colors}
candidates_df <- data.frame(
  id = 0:9,
  colname = c(
    "pres_1_abella", "pres_2_de_guzman", "pres_3_domagoso", "pres_4_gonzales", 
    "pres_5_lacson", "pres_6_mangondato", "pres_7_marcos", 
    "pres_8_montemayor", "pres_9_pacquiao", "pres_10_robredo"
  ),
  candidate_name = c(
    "Ernesto Abella", "Leody de Guzman", "Isko Moreno Domagoso", "Norberto Gonzales",
    "Panfilo Lacson", "Faisal Mangondato", "Ferdinand Marcos Jr.",
    "Jose Montemayor Jr.", "Manny Pacquiao", "Leni Robredo"
  ),
  campaign_color = c(
    "#808080", "#FFA500", "#0074D9", "#228B22",
    "#DDDDDD", "#8B4513", "#D50000",
    "#90EE90", "#FFD700", "#FF69B4"
  ),
  stringsAsFactors = FALSE
)

colnames(candidates_df)
```
### Total Votes Preview

Next, I want a quick summary of the total votes per candidate during the election.Since I have a `pres_df` containing their candidate names and notice that colname serves as the reference for both dataframe. Then, I added a column in the `candidates_df` to count all their corresponding votes throughout the country. 

In this chunk, each row will be checked out based on the according `colname` from `candidates_df`. This statement translates into "sum all votes from this column."

```{r Quick Preview}
candidates_df <- candidates_df %>%
  rowwise() %>%
  mutate(total_votes = sum(pres_df[[colname]])) %>%
  ungroup() 

candidates_df %>%
  select(candidate_name, total_votes) %>%
  arrange(desc(total_votes))
```

### Bar Chart of 2022 Philippine Presidential Election

Now, let's visualize that. To make the plot interactive, you can use ggplotly.

```{r Plotting the preview}
ggplot(candidates_df, aes(x = reorder(candidate_name, -total_votes),
                                  y = total_votes,
                                  fill = I(campaign_color))) + 
  geom_bar(stat = "identity") +
  scale_fill_identity() + 
  scale_y_continuous(labels = comma) +
  labs(
    title = "2022 Philippine Presidential Election",
    x = "Candidate",
    y = "Total Votes"
  ) +
  theme (
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

# Assign plot to a variable named `plot`, run this code:
# ggplotly(plot)  
```

### Candidate Winners per City

Now, let's see all the city across the country and see which candidates they voted most. 

```{r City Winners}
city_winners <- pres_df %>% 
  group_by(city) %>%
  # Checks all president vote columns, sums it all up (discards null values)
  summarize(across(starts_with("pres_"), sum, na.rm = TRUE)) %>%
  rowwise() %>%
  # Checks each column in every row to find the column that have the highest vote.
  mutate(winner = names(.)[which.max(c_across(starts_with("pres_")))]) %>%
  ungroup() 
```

### Getting GeoJSON of the country's regions

What we want to do is color each region of the country based on which candidate was voted the most. With the current dataset, that is not possible so we need to find a way to find and locate each region. Luckily, we have that information online: click [here](https://gadm.org/download_country.html) to download the country's (level 2) GeoJSON. 

```{r Reading PH Geodata}
ph_geo <- st_read("PH_GeoJSON.json")
# colnames(ph_geo)
```

Great, now we have the geometry coordinates of the cities. Note that the cities in `PH_GeoJSON`, the city column is named NAME_2, in sentence casing, and no spaces. We need to fix that first to be able to merge the two dataframes.

Let's first clean both dataframe's city column by creating a new column to turn both `pres_df(city)` and `ph_geo(NAME_2)` to lowercase and named `city_clean`

```{r Cleaning the data}
pres_df <- pres_df %>%
    mutate(city_clean = str_to_lower(str_replace_all(city, "\\s+", "")))
ph_geo <- ph_geo %>% 
    mutate(city_clean = str_to_lower(str_replace_all(NAME_2, "\\s+", "")))
city_winners <- city_winners %>% 
      mutate(city_clean = str_to_lower(str_replace_all(city, "\\s+", "")))
```

Now, let's merge the two dataframes.

```{r Merging the dataframes}
city_winners <- city_winners %>%
  # In the city winners, you'll be able to see the votes per city, candidate who won, their campaign color, and the city's geometry.
  left_join(select(ph_geo, city_clean, geometry), by = "city_clean") %>% 
  left_join(select(candidates_df, colname, campaign_color), by = c("winner" = "colname"))

# Here, we need to convert the dataframe into a sf object
city_winners <- st_as_sf(city_winners, sf_column_name = "geometry")
st_geometry(city_winners)

```

We now have the winners per city and the coordinates of the cities. We can now do a geocomputation map.

```{r}
ggplot(data = city_winners) +
  geom_sf(aes(fill = campaign_color), size = 0.2) +
  scale_fill_identity() +
  labs(title = "2022 PH Presidential Election: City Winners by Campaign Color",
       fill = "Winner")
```